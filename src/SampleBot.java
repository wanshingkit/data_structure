import battleship.BattleShip;

import java.awt.*;
import java.util.ArrayList;

/**
 * A Sample random shooter - it implements
 * - preparation to shooting strategy
 * - the method shows the strategy
 *
 * @author group member
 * shing kit wan-000826521
 * yeshey dema-000824243
 * Eugenio Diaz Munoz-000801681
 */
public class SampleBot {
    public ArrayList<Point> hitRecord = new ArrayList<>();// if hit something, record here
    private int gameSize;//length of each game board edge
    private BattleShip battleShip;//game object
    private int location = -1;//grid counter
    private ArrayList<Point> shotHistory = new ArrayList<>();//an array that store [x,y] coordinate of current location of shooting
    private PriorityQueue<Point> surroundShots;//after hit some grid in the scanShot(), enter the sink mode, take points surround the hit grid like a cross shape. and add them into queue in sequence in addSurroundShot()


    /**
     * Constructor keeps a copy of the BattleShip instance
     * also start the Queue surroundShots here
     *
     * @param b previously created battleship instance - should be a new game
     */
    public SampleBot(BattleShip b) {
        battleShip = b;
        gameSize = b.boardSize;
        surroundShots = new PriorityQueue<>();
    }


    /**
     * -Create a shot that is generated by decideShot()
     * -calls the battleship shoot method
     * -record the shot location in ArrayList shotHistory
     * -if hit, it records location in ArrayList hitRecord
     * and call addSurroundShot() with parameter with shot generated in line58,
     * that turn hunt mode to sink mode.
     */

    public void fireShot() {
        Point shot = decideShot();
        boolean hit = battleShip.shoot(shot);
        shotHistory.add(shot);
        if (hit) {
            hitRecord.add(shot);
            addSurroundShot(shot);
        }

    }


    /**
     * if the ship is shot, see if where shall we place the second shot (aim to hunt 2 grid ship)
     * second shot has different shooting strategy in edge, corner and inner part of the grid
     *
     * @return a point that generate from surroundShot() (a sink mode strategy) or scanShot() (a hunt mode strategy)
     */
    private Point decideShot() {
        //if there is still Points in SurroundShots Priority Queue, make use of it through surroundShot() (sink mode)
        if (!surroundShots.isEmpty()) {
            return surroundShot();
        }//otherwise use scanShot() (hunt mode)
        return scanShot();
    }

    /**
     * this is designed, when you hit one grid of the ship, you look for the second point of the ship
     * by
     * 1. use pointOK(Point) check the first point in Priority Queue surroundShots is both inside gameboard and
     * not shot before.
     * 2.if not OK to shoot, take out that point from Queue surroundShots and go back to decideShot() again
     * 3. if OK to shoot, return that element by building a Point
     *
     * @return if not OK to shoot, its a point from decideShot() again.if OK to shoot, its a Point from 1st element of surroundShots
     */
    private Point surroundShot() {
        if (!pointOK(surroundShots.peek())) {//examine surroundShots 1st element create Point OK to shoot?
            surroundShots.dequeue(); //no, then delete it
            return decideShot();//go back to decideShot() in line 76
        }
        return new Point(surroundShots.dequeue());
    }

    /**
     * this add the surrounding shot into array that we head for surround shots, a strategy to shoot like shape "十" around the parameter
     * <p>
     * we have a mentality of prioritise the shooting strategy as follow:
     * 1. if we find out there are tendency that the hit goes one direction, we tend to go prioritise for that direction first
     * this can be examine by seeing if the hits are neighbors
     * 2. As we shoot from 0,0 to 10,10 normally. so there are less chance we encounter empty slots on top than bottom
     * 3. same as 2, as we scan from left to right, left should have less chance we encounter empty slots
     * 4. after we scan right at 3rd point, we go for left
     * 5. then we finally scan top.
     *
     * @param point that just hit a ship
     */
    private void addSurroundShot(Point point) {

        //in case there are track records of where we hit, we can know if there are recently hit
        //a direction can develop upon the current shot and the last shot
        if (hitRecord.size() > 1) {

            // first we use if statement to find out if recent 2 hits are neighbours in x axis
            if (Math.abs(hitRecord.get(hitRecord.size() - 1).x - hitRecord.get(hitRecord.size() - 2).x) == 1) {
                if (pointOK(new Point(point.x + 1, point.y)))
                    surroundShots.enqueue(new Point(point.x + 1, point.y), 1); //shoot points on same x axis 1st
                if (pointOK(new Point(point.x - 1, point.y)))
                    surroundShots.enqueue(new Point(point.x - 1, point.y), 1);//shoot points on same x axis 1st
                if (pointOK(new Point(point.x, point.y - 1)))
                    surroundShots.enqueue(new Point(point.x, point.y - 1), 5);//then consider y axis
                if (pointOK(new Point(point.x, point.y + 1)))
                    surroundShots.enqueue(new Point(point.x, point.y + 1), 2);//then consider y axis
            }
            // also we use if statement to find out if recent 2 hits are neighbours in y axis
            if (Math.abs(hitRecord.get(hitRecord.size() - 1).y - hitRecord.get(hitRecord.size() - 2).y) == 1) {
                if (pointOK(new Point(point.x, point.y + 1)))
                    surroundShots.enqueue(new Point(point.x, point.y + 1), 1);//shoot points on same y axis 1st
                if (pointOK(new Point(point.x + 1, point.y)))
                    surroundShots.enqueue(new Point(point.x + 1, point.y), 3);//shoot points on same y axis 1st
                if (pointOK(new Point(point.x - 1, point.y)))
                    surroundShots.enqueue(new Point(point.x - 1, point.y), 4);//then consider x axis
                if (pointOK(new Point(point.x, point.y - 1)))
                    surroundShots.enqueue(new Point(point.x, point.y - 1), 1);//then consider x axis
            }
        }

        //at the beginning, we do not have enough track history to know where the direction goes
        //so we consider the bottom and right hand as rather high priority, as these two
        //directions are rather less explored by scanShot() (the parity scan)
        if (pointOK(new Point(point.x, point.y + 1)))
            surroundShots.enqueue(new Point(point.x, point.y + 1), 2);//priority 2 on bottom point of 十
        if (pointOK(new Point(point.x + 1, point.y)))
            surroundShots.enqueue(new Point(point.x + 1, point.y), 3);//priority 3 on right point of 十
        if (pointOK(new Point(point.x - 1, point.y)))
            surroundShots.enqueue(new Point(point.x - 1, point.y), 4);//priority 4 on left point of 十
        if (pointOK(new Point(point.x, point.y - 1)))
            surroundShots.enqueue(new Point(point.x, point.y - 1), 5);//priority 5 on top point of 十

    }


    /**
     * Examine a point whether it is inside game board + didnt shoot before
     *
     * @param point to examine
     * @return boolean location not shoot+inside gameboard
     */
    private boolean pointOK(Point point) {
        return point.x >= 0 && point.y >= 0 && point.x < gameSize && point.y < gameSize && !shotHistory.contains(point);
    }

    /**
     * Hunting mode, generate parity scan.
     * if x and y add together the modulus is not 0, the last if statement will break the while loop and return the coordinate we are aiming to decideShot()
     * and decideshot() will pass it on to fireShot() and shoot this coordinate
     * <p>
     * if x and y add together the modulus is 0 or we shoot before, it will not break, and carry on to next loop without doing anything.
     *
     * @return Point for shoot in hunting mode
     */
    private Point scanShot() {
        int x;
        int y;
        Point temp;
        while (true) {
            location++;
            x = location % gameSize;
            y = location / gameSize;
            temp = new Point(x, y);

            if (shotHistory.contains(temp)) {
                continue;
            }
            if ((y + x) % 2 == 0) {//if they
                break;
            }

        }
        return temp;
    }
}
